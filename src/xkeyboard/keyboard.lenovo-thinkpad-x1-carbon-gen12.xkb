# https://xkbcommon.org/doc/current/keymap-text-format-v1.html
# https://wiki.archlinux.org/title/Xorg/Keyboard_configuration
# https://wiki.archlinux.org/title/X_keyboard_extension
# https://who-t.blogspot.com/2020/02/user-specific-xkb-configuration-part-1.html

# To output current map: xkbcomp $DISPLAY -
# see also xkb-file (executable)

# In principle, you can reload a file with xkbcomp FILENAME $DISPLAY; but this
# probably won't work appropriately on wayland; use sway-reload for that

# be sure to test running emacs vlc when you change this:
# -) emacs behaves differently wrt modifiers
# -) vlc can fail to respond to keys; look for
#      `qt.qpa.xkeyboard: failed to compile a keymap`
#    in the output.  This seems to be caused by a lack of level_name settings in
#    (any) `type`


# https://github.com/swaywm/sway/issues/5461
# if in doubt, compile this file with `xkbcomp FILE $DISPLAY`
# (xkbcomp is from xorg.xkbcomp)
# e.g., sway may reload happily, but emacs will bork (and probably revert to the
# hard keyboard, i.e., qwerty)

# note that dead keys need to be configured in XCompose

xkb_keymap {
  xkb_keycodes {
    minimum = 8;
    maximum = 255;

    # --------------------------------------------------------

    <ESC>  =   9;
    <FK01> =  67;
    <FK02> =  68;
    <FK03> =  69;
    <FK04> =  70;
    <FK05> =  71;
    <FK06> =  72;
    <FK07> =  73;
    <FK08> =  74;
    <FK09> =  75;
    <FK10> =  76;
    <FK11> =  95;
    <FK12> =  96;

    # ------------------------------------

    <HOME> = 110;
    <END>  = 115;
    <INS>  = 118;
    <DELE> = 119;

    # --------------------------------------------------------

    <MUTE> = 121; # Fn+FK1
    <VOL-> = 122; # Fn+FK2
    <VOL+> = 123; # Fn+FK3
    <MCMT> = 198; # Fn+FK4: Mic Mute
    <BRT-> = 232; # Fn+FK5: Brightness Down
    <BRT+> = 233; # Fn+FK6: Brightness Up
    <DISP> = 235; # Fn+FK7: Display
    # No key code for Fn+FK8
    <PRSC> = 107; # Fn+FK9
    <SNIP> = 157; # Fn+FK10
    # No key code for Fn+FK11
    <STAR> = 164; # Fn+FK12

    # --------------------------------------------------------

    <BKTK> =  49; # Backtick
    <NUM1> =  10;
    <NUM2> =  11;
    <NUM3> =  12;
    <NUM4> =  13;
    <NUM5> =  14;
    <NUM6> =  15;
    <NUM7> =  16;
    <NUM8> =  17;
    <NUM9> =  18;
    <NUM0> =  19;
    <MNUS> =  20;
    <EQUL> =  21;
    <BKSP> =  22;

    # --------------------------------------------------------

    <TAB>  =  23; <FTAB> = 380; # Fn+TAB
    <KP_Q> =  24;
    <KP_W> =  25;
    <KP_E> =  26;
    <KP_R> =  27;
    <KP_T> =  28;
    <KP_Y> =  29;
    <KP_U> =  30;
    <KP_I> =  31;
    <KP_O> =  32;
    <KP_P> =  33; <PAUS> = 127; # Fn+p
    <LBRK> =  34; # left bracket
    <RBRK> =  35; # right bracket

    # --------------------------------------------------------

    <CAPS> =  66;
    <KP_A> =  38;
    <KP_S> =  39;
    <KP_D> =  40;
    <KP_F> =  41;
    <KP_G> =  42;
    <KP_H> =  43;
    <KP_J> =  44;
    <KP_K> =  45; <SCLK> = 78; # Fn+k

    <KP_L> =  46;
    <SEMI> =  47; # semicolon
    <APOS> =  48; # apostrophe
    <HASH> =  51;
    <RTRN> =  36;

    # --------------------------------------------------------

    <LFSH> =  50; # left shift
    <BKSL> =  94;
    <KP_Z> =  52;
    <KP_X> =  53;
    <KP_C> =  54;
    <KP_V> =  55;
    <KP_B> =  56;
    <KP_N> =  57;
    <KP_M> =  58;
    <COMM> =  59; # comma
    <PERD> =  60; # period
    <SLSH> =  61; # slash
    <RTSH> =  62; <FRSH> = 210; # right shift; Fn+RShift

    # --------------------------------------------------------

    <LCTL> =  37;
    <I151> = 151;
    <LWIN> = 133;
    <LALT> =  64;
    <SPCE> =  65;
    <RALT> = 108;
    <RCTL> = 105;

    <PGUP> = 112;
    <UP>   = 111;
    <PGDN> = 117;
    <LEFT> = 113;
    <DOWN> = 116;
    <RGHT> = 114;

    # --------------------------------------------------------

    # where the indicator is; see xkb_compatibility/indicator for usage
    indicator 1 = "Caps Lock";
  };

  xkb_types "(unnamed)" {
    # modifier bits:
    # 01 - Shift
    # 02 - Lock (as in CapsLock)
    # 04 - Control
    # 08 - Mod1 (Alt/Meta)
    # 10 - Mod2 (diacritics, etc.)
    # 20 - Mod3
    # 40 - Mod4
    # 80 - Mod5 (LevelThree)

    # we mostly leave Control, Alt + Super for apps, etc., to read directly

    virtual_modifiers NumLock,Alt,LevelThree,LevelFive,Meta,Super,Hyper,ScrollLock;

    type "ONE_LEVEL" { modifiers= none; level_name[Level1]= "Any"; };

    # I did try renaming this to "SHIFT", but per
    # https://xkbcommon.org/doc/current/keymap-text-format-v1.html ,
    # "TWO_LEVEL" is the name used as a default for two-keysym groups
    type "TWO_LEVEL" {
      modifiers          = Shift;
      map[Shift]         = Level2;
      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
    };

    type "CONTROL" {
      modifiers          = Control;
      map[Control]       = Level2;
      level_name[Level1] = "Base";
      level_name[Level2] = "Control";
    };

    type "Mod5" {
      modifiers          = Mod5;
      map[Mod5]          = Level2;
      level_name[Level1] = "Base";
      level_name[Level2] = "Mod5";
    };

    type "Mod3:Mod5" {
      modifiers          = Mod3+Mod5;
      map[Mod3]          = Level2;
      map[Mod5]          = Level2;
      map[Mod3+Mod5]     = Level2;
      level_name[Level1] = "Base";
      level_name[Level2] = "Mod5";
    };

    type "CTRL-ALT" {
      # ignore control, alt individually: react only to ctrl+alt together
      modifiers          = Control+Mod1;
      map[Control+Mod1]  = Level2;
      level_name[Level1] = "Base";
      level_name[Level2] = "Control+Mod1";
    };

    type "CTRL-ALT-MOD3" {
      # ignore control, alt individually: react only to ctrl+alt together
      modifiers          = Control+Mod1+Mod3;
      map[Control+Mod1]  = Level2;
      map[Mod3]          = Level3;
      level_name[Level1] = "Base";
      level_name[Level2] = "Control+Mod1";
      level_name[Level3] = "Mod3";
    };

    type "CTRL+ALT" {
      modifiers          = Control+Mod1;
      map[Control]       = Level2;
      map[Mod1]          = Level3;
      map[Control+Mod1]  = Level4;
      level_name[Level1] = "Base";
      level_name[Level2] = "Control";
      level_name[Level3] = "Mod1";
      level_name[Level4] = "Control+Mod1";
    };

    type "FOUR_LEVEL" {
      # the levels are:
      # 0: unmolested
      # 1: shift
      # 2: mod5(ralt)
      # 3: mod5(ralt)+shift

      modifiers          = Shift+Mod5;
      map[Shift]         = Level2;
      map[Mod5]          = Level3;
      map[Shift+Mod5]    = Level4;
      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
      level_name[Level3] = "AltGr";
      level_name[Level4] = "Shift AltGr";
    };

    type "EIGHT_LEVEL" {
      # the levels are:
      # 0: unmolested
      # 1: shift
      # 2: mod5(ralt)
      # 3: mod5(ralt)+shift
      # 4: super(lwin)
      # 5: super(lwin)+shift
      # 6: super(lwin)+mod5(ralt)
      # 7: super(lwin)+mod5(ralt)+shift

      modifiers            = Shift+Mod5+Mod3;
      map[Shift]           = Level2;
      map[Mod5]            = Level3;
      map[Shift+Mod5]      = Level4;
      map[Mod3]            = Level5;
      map[Shift+Mod3]      = Level6;
      map[Mod5+Mod3]       = Level7;
      map[Shift+Mod5+Mod3] = Level8;
      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
      level_name[Level3] = "AltGr";
      level_name[Level4] = "Shift AltGr";
      level_name[Level5] = "X";
      level_name[Level6] = "X Shift";
      level_name[Level7] = "X AltGr";
      level_name[Level8] = "X Shift AltGr";
    };
    type "EIGHT_LEVEL_ALPHABETIC" {
      modifiers                 = Shift+Lock+Mod5+Mod3;
      map[Shift]                = Level2;
      map[Lock]                 = Level2;
      map[Mod5]                 = Level3;
      map[Shift+Mod5]           = Level4;
      map[Lock+Mod5]            = Level4;
      map[Shift+Lock+Mod5]      = Level3;
      map[Mod3]                 = Level5;
      map[Shift+Mod3]           = Level6;
      map[Lock+Mod3]            = Level6;
      map[Shift+Lock+Mod3]      = Level5;
      map[Mod5+Mod3]            = Level7;
      map[Shift+Mod5+Mod3]      = Level8;
      map[Lock+Mod5+Mod3]       = Level8;
      map[Shift+Lock+Mod5+Mod3] = Level7;

      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
      level_name[Level3] = "AltGr";
      level_name[Level4] = "Shift AltGr";
      level_name[Level5] = "X";
      level_name[Level6] = "X Shift";
      level_name[Level7] = "X AltGr";
      level_name[Level8] = "X Shift AltGr";
    };

    type "SHIFT-ALT" {
        modifiers= Shift+Alt;
        map[Shift+Alt]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift+Alt";
    };

    # these entries, ALPHABETIC & KEYPAD; seem to be necessary for vlc to work
    # (and possibly other Qt-based apps, too)

    type "ALPHABETIC" {
        modifiers= Shift+Lock;
        map[Shift]= Level2;
        map[Lock]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Caps";
    };

    type "KEYPAD" {
        modifiers= Shift+NumLock;
        map[NumLock]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Number";
    };
  };

xkb_compatibility "(unnamed)" {

  # SetMods makes a regular "on while pressed" modifier key. LockMods makes an
  # "on/off" switch like CapsLock or NumLock. LatchMods means "on until next
  # keypress" aka sticky modifier.

  # from https://wiki.archlinux.org/title/X_keyboard_extension#xkb_compatibility :
  #
  # Warning: four standard types, ONE_LEVEL, TWO_LEVEL, ALPHABETIC and KEYPAD,
  # receive special treatment in xkbcomp(1). They may work differently just
  # because they are named this way. Avoid deleting them. If some changes do not
  # work as expected, try adding a new type instead.

  virtual_modifiers NumLock,Alt,LevelThree,LevelFive,Meta,Super,Hyper,ScrollLock;

    interpret.useModMapMods= AnyLevel;
    interpret.repeat= False;
    interpret.locking= False;
    interpret ISO_Level2_Latch+Exactly(Shift) {
        useModMapMods=level1;
        action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
    };
    interpret Shift_Lock+AnyOf(Shift+Lock) {
        action= LockMods(modifiers=Shift);
    };
    interpret Num_Lock+AnyOf(all) {
        virtualModifier= NumLock;
        action= LockMods(modifiers=NumLock);
    };
    interpret ISO_Level3_Shift+AnyOf(all) {
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret ISO_Level3_Latch+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LockMods(modifiers=LevelThree);
    };
    interpret Alt_L+AnyOf(all) {
        virtualModifier= Alt;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Alt_R+AnyOf(all) {
        virtualModifier= Alt;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Meta_L+AnyOf(all) {
        virtualModifier= Meta;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Meta_R+AnyOf(all) {
        virtualModifier= Meta;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Super_L+AnyOf(all) {
        virtualModifier= Super;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Super_R+AnyOf(all) {
        virtualModifier= Super;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Hyper_L+AnyOf(all) {
#        virtualModifier= Hyper;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Hyper_R+AnyOf(all) {
        virtualModifier= Hyper;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret ISO_Level5_Shift+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= SetMods(modifiers=LevelFive,clearLocks);
    };
    interpret ISO_Level5_Latch+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= LatchMods(modifiers=LevelFive,clearLocks,latchToLock);
    };
    interpret ISO_Level5_Lock+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= LockMods(modifiers=LevelFive);
    };

    # Note that key+AnyOfOrNone(all) is equivalent to just key, but key is much
    # easier to read.
    interpret Mode_switch {
        action= SetGroup(group=+1);
    };
    interpret ISO_Level3_Shift {
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret ISO_Level3_Latch {
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock {
        action= LockMods(modifiers=LevelThree);
    };
    interpret ISO_Group_Latch {
        action= LatchGroup(group=2);
    };
    interpret ISO_Next_Group {
        action= LockGroup(group=+1);
    };
    interpret ISO_Prev_Group {
        action= LockGroup(group=-1);
    };
    interpret ISO_First_Group {
        action= LockGroup(group=1);
    };
    interpret ISO_Last_Group {
        action= LockGroup(group=2);
    };
    interpret KP_1 {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret KP_End {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret KP_2 {
        repeat= True;
        action= MovePtr(x=+0,y=+1);
    };
    interpret KP_Down {
        repeat= True;
        action= MovePtr(x=+0,y=+1);
    };
    interpret KP_3 {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret KP_Next {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret KP_4 {
        repeat= True;
        action= MovePtr(x=-1,y=+0);
    };
    interpret KP_Left {
        repeat= True;
        action= MovePtr(x=-1,y=+0);
    };
    interpret KP_6 {
        repeat= True;
        action= MovePtr(x=+1,y=+0);
    };
    interpret KP_Right {
        repeat= True;
        action= MovePtr(x=+1,y=+0);
    };
    interpret KP_7 {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret KP_Home {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret KP_8 {
        repeat= True;
        action= MovePtr(x=+0,y=-1);
    };
    interpret KP_Up {
        repeat= True;
        action= MovePtr(x=+0,y=-1);
    };
    interpret KP_9 {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret KP_Prior {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret KP_5 {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret KP_Begin {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret KP_F2 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret KP_Divide {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret KP_F3 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret KP_Multiply {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret KP_F4 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=3);
    };
    interpret KP_Subtract {
        repeat= True;
        action= SetPtrDflt(affect=button,button=3);
    };
    interpret KP_Separator {
        repeat= True;
        action= PtrBtn(button=default,count=2);
    };
    interpret KP_Add {
        repeat= True;
        action= PtrBtn(button=default,count=2);
    };
    interpret KP_0 {
        repeat= True;
        action= LockPtrBtn(button=default,affect=lock);
    };
    interpret KP_Insert {
        repeat= True;
        action= LockPtrBtn(button=default,affect=lock);
    };
    interpret KP_Decimal {
        repeat= True;
        action= LockPtrBtn(button=default,affect=unlock);
    };
    interpret KP_Delete {
        repeat= True;
        action= LockPtrBtn(button=default,affect=unlock);
    };
    interpret F25 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret F26 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret F27 {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret F29 {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret F31 {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret F33 {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret F35 {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret Pointer_Button_Dflt {
        action= PtrBtn(button=default);
    };
    interpret Pointer_Button1 {
        action= PtrBtn(button=1);
    };
    interpret Pointer_Button2 {
        action= PtrBtn(button=2);
    };
    interpret Pointer_Button3 {
        action= PtrBtn(button=3);
    };
    interpret Pointer_DblClick_Dflt {
        action= PtrBtn(button=default,count=2);
    };
    interpret Pointer_DblClick1 {
        action= PtrBtn(button=1,count=2);
    };
    interpret Pointer_DblClick2 {
        action= PtrBtn(button=2,count=2);
    };
    interpret Pointer_DblClick3 {
        action= PtrBtn(button=3,count=2);
    };
    interpret Pointer_Drag_Dflt {
        action= LockPtrBtn(button=default,affect=both);
    };
    interpret Pointer_Drag1 {
        action= LockPtrBtn(button=1,affect=both);
    };
    interpret Pointer_Drag2 {
        action= LockPtrBtn(button=2,affect=both);
    };
    interpret Pointer_Drag3 {
        action= LockPtrBtn(button=3,affect=both);
    };
    interpret Pointer_EnableKeys {
        action= LockControls(controls=MouseKeys);
    };
    interpret Pointer_Accelerate {
        action= LockControls(controls=MouseKeysAccel);
    };
    interpret Pointer_DfltBtnNext {
        action= SetPtrDflt(affect=button,button=+1);
    };
    interpret Pointer_DfltBtnPrev {
        action= SetPtrDflt(affect=button,button=-1);
    };
    interpret AccessX_Enable {
        action= LockControls(controls=AccessXKeys);
    };
    interpret AccessX_Feedback_Enable {
        action= LockControls(controls=AccessXFeedback);
    };
    interpret RepeatKeys_Enable {
        action= LockControls(controls=RepeatKeys);
    };
    interpret SlowKeys_Enable {
        action= LockControls(controls=SlowKeys);
    };
    interpret BounceKeys_Enable {
        action= LockControls(controls=BounceKeys);
    };
    interpret StickyKeys_Enable {
        action= LockControls(controls=StickyKeys);
    };
    interpret MouseKeys_Enable {
        action= LockControls(controls=MouseKeys);
    };
    interpret MouseKeys_Accel_Enable {
        action= LockControls(controls=MouseKeysAccel);
    };
    interpret Overlay1_Enable {
        action= LockControls(controls=none);
    };
    interpret Overlay2_Enable {
        action= LockControls(controls=none);
    };
    interpret AudibleBell_Enable {
        action= LockControls(controls=AudibleBell);
    };
    interpret Terminate_Server {
        action= Terminate();
    };
    interpret Alt_L {
        action= SetMods(modifiers=Alt,clearLocks);
    };
    interpret Alt_R {
        action= SetMods(modifiers=Alt,clearLocks);
    };
    interpret Meta_L {
        action= SetMods(modifiers=Meta,clearLocks);
    };
    interpret Meta_R {
        action= SetMods(modifiers=Meta,clearLocks);
    };
    interpret Super_L {
        action= SetMods(modifiers=Super,clearLocks);
    };
    interpret Super_R {
        action= SetMods(modifiers=Super,clearLocks);
    };
    interpret Hyper_L {
#        action= SetMods(modifiers=Hyper,clearLocks);
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Hyper_R {
#        action= SetMods(modifiers=Hyper,clearLocks);
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret Shift_L {
        action= SetMods(modifiers=Shift,clearLocks);
    };
    interpret Shift_R {
        action= SetMods(modifiers=Shift,clearLocks);
    };
    interpret XF86Switch_VT_1 {
        repeat= True;
        action= SwitchScreen(screen=1,!same);
    };
    interpret XF86Switch_VT_2 {
        repeat= True;
        action= SwitchScreen(screen=2,!same);
    };
    interpret XF86Switch_VT_3 {
        repeat= True;
        action= SwitchScreen(screen=3,!same);
    };
    interpret XF86Switch_VT_4 {
        repeat= True;
        action= SwitchScreen(screen=4,!same);
    };
    interpret XF86Switch_VT_5 {
        repeat= True;
        action= SwitchScreen(screen=5,!same);
    };
    interpret XF86Switch_VT_6 {
        repeat= True;
        action= SwitchScreen(screen=6,!same);
    };
    interpret XF86Switch_VT_7 {
        repeat= True;
        action= SwitchScreen(screen=7,!same);
    };
    interpret XF86Switch_VT_8 {
        repeat= True;
        action= SwitchScreen(screen=8,!same);
    };
    interpret XF86Switch_VT_9 {
        repeat= True;
        action= SwitchScreen(screen=9,!same);
    };
    interpret XF86Switch_VT_10 {
        repeat= True;
        action= SwitchScreen(screen=10,!same);
    };
    interpret XF86Switch_VT_11 {
        repeat= True;
        action= SwitchScreen(screen=11,!same);
    };
    interpret XF86Switch_VT_12 {
        repeat= True;
        action= SwitchScreen(screen=12,!same);
    };
    interpret XF86LogGrabInfo {
        repeat= True;
        action= Private(type=0x86,data[0]=0x50,data[1]=0x72,data[2]=0x47,data[3]=0x72,data[4]=0x62,data[5]=0x73,data[6]=0x00);
    };
    interpret XF86LogWindowTree {
        repeat= True;
        action= Private(type=0x86,data[0]=0x50,data[1]=0x72,data[2]=0x57,data[3]=0x69,data[4]=0x6e,data[5]=0x73,data[6]=0x00);
    };
    interpret XF86Next_VMode {
        repeat= True;
        action= Private(type=0x86,data[0]=0x2b,data[1]=0x56,data[2]=0x4d,data[3]=0x6f,data[4]=0x64,data[5]=0x65,data[6]=0x00);
    };
    interpret XF86Prev_VMode {
        repeat= True;
        action= Private(type=0x86,data[0]=0x2d,data[1]=0x56,data[2]=0x4d,data[3]=0x6f,data[4]=0x64,data[5]=0x65,data[6]=0x00);
    };
    interpret ISO_Level5_Shift {
        action= SetMods(modifiers=LevelFive,clearLocks);
    };
    interpret ISO_Level5_Latch {
        action= LatchMods(modifiers=LevelFive,clearLocks,latchToLock);
    };
    interpret ISO_Level5_Lock {
        action= LockMods(modifiers=LevelFive);
    };
    interpret Caps_Lock {
        action= LockMods(modifiers=Lock);
    };
    interpret Any+Exactly(Lock) {
        action= LockMods(modifiers=Lock);
    };
    interpret Any+AnyOf(all) {
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    indicator "Caps Lock" {
#        whichModState= Locked;
#        modifiers= Lock;
        whichModState= Any;
        modifiers= Lock;
    };
  };

  xkb_symbols "lenovo thinkpad X1 carbon Gen12" {
              # used, e.g., on the lock screen
    name[1]="English (UK, dvorak, F12, bottom-left backslash, w/ dead keys)";
    name[2]="English (UK, qwerty, F12, bottom-left backslash, w/ dead keys)";

    # --  <ESC> F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 <HOME> <END> <INS> <DEL> --
    #
    # -- 9(ESC),67-76(F1-F10),95-96(F11-F12),110(HOME),115(END),118(INS),119(DEL)

    # 121-123(Fn+F1-Fn+F3),198(Fn+F4),232(Fn+F5),233(Fn+F6),
    # 235(Fn+F7),NOTHING(Fn+F8),107(Fn+F9),157(Fn+F10),NOTHING(Fn+F11),164(Fn+F12)
    #
    # Fn+p: 127
    # Fn+TAB: 380
    # Fn+s: 64+107
    # Fn+k: 78
    # Fn+RShft: 210
    # Fn+B: 37+127
    # Fn+LShft: 50 (same as LShft)
    # Fn+Left:110
    # Fn+Right:115


    key <ESC>  { [ Escape ] };
    key <FK01> { type = "CTRL-ALT-MOD3", symbols= [ F1,  XF86Switch_VT_1, dead_acute ] };
    key <FK02> { type = "CTRL-ALT", symbols= [ F2,  XF86Switch_VT_2  ] };
    key <FK03> { type = "CTRL-ALT", symbols= [ F3,  XF86Switch_VT_3  ] };
    key <FK04> { type = "CTRL-ALT", symbols= [ F4,  XF86Switch_VT_4  ] };
    key <FK05> { type = "CTRL-ALT", symbols= [ F5,  XF86Switch_VT_5  ] };
    key <FK06> { type = "CTRL-ALT", symbols= [ F6,  XF86Switch_VT_6  ] };
    key <FK07> { type = "CTRL-ALT", symbols= [ F7,  XF86Switch_VT_7  ] };
    key <FK08> { type = "CTRL-ALT", symbols= [ F8,  XF86Switch_VT_8  ] };
    key <FK09> { type = "CTRL-ALT", symbols= [ F9,  XF86Switch_VT_9  ] };
    key <FK10> { type = "CTRL-ALT", symbols= [ F10, XF86Switch_VT_10 ] };
    key <FK11> {
      type    = "CTRL-ALT-MOD3",
      symbols = [ VoidSymbol, XF86Switch_VT_11, F11 ],
      actions = [ SetMods(modifiers=Mod2,clearLocks) ]
    };
    key <FK12> { type = "CTRL-ALT-MOD3", symbols= [ Multi_key, XF86Switch_VT_12, F12 ] };

    key <HOME> { [ Home   ] };
    key <END>  { [ End    ] };
    key <INS>  { [ Insert ] };
    key <DELE> { [ Delete ] };


    key <BKSP> { [ BackSpace, BackSpace ] };

    # -- <TAB> qwertuiop [] ----------------------------------------------------
    #
    # -- 23-35(TAB,q-l,[])

    key <TAB>  { type="TWO_LEVEL", [ Tab, ISO_Left_Tab ] };

    # -- <CAPS> asdfghjkl;'# -----------------------------------------------------
    #
    # -- 66(CAPS),38-48(a-l,;,'),51(#),36(RTRN)

    key <CAPS> {
      type    = "CTRL-ALT",
      symbols = [ Control_L, Caps_Lock ],
      actions = [ SetMods(modifiers=Control), LockMods(modifiers=Lock)]
    };
    key <RTRN> { [ Return ] };

    # -- <LFSH> \zxcvbnm,./ <RTSH> -----------------------------------------------
    #
    # -- 50(LSHFT),94(BCKSLSH),52-62(z-m,,./RSHFT)

    key <LFSH> { [ Shift_L ] };
    key <RTSH> { [ Shift_R ] };

    # -- <CTL> <FN> <SPR> <ALT> <SPACEBAR> <ALTGR> <CTL> (FNGR) ----------------
    #
    # -- 37(LCTL),151(FN),133(SUPER),64(ALT),65(SPACE),108(ALTGR),105(RCTL), ---
    # ---- 112(PGUP),111(UP),117(PGDN),113(LEFT),116(DOWN),114(RGHT) -----------

    key <LCTL> { [ Control_L     ] };
    key <LWIN> { [ Super_L       ] };
    key <LALT> { [ Alt_L, Meta_L ] };
    key <SPCE> { type="Mod3:Mod5", [ space, nobreakspace ] };
    # don't use alt_r here, as then emacs reads that as Alt modifier
    key <RALT> { actions=[SetMods(modifiers=Mod5,clearLocks)] };
    key <RCTL> { [ Control_R     ] };

    # <PGUP> <UP> <PGDN> <LEFT> <DOWN> <RGHT> ----------------

    key <PGUP> { type = "CTRL-ALT", symbols=[ Prior,ISO_Prev_Group ] };
    key  <UP>  { [ Up    ] };
    key <PGDN> { type = "CTRL-ALT", symbols=[ Next,ISO_Next_Group ] };
    key <LEFT> { [ Left  ] };
    key <DOWN> { [ Down  ] };
    key <RGHT> { [ Right ] };

    # ----------------------------------------------------------------------------


    # key <SCLK> {         [     Scroll_Lock ] };

    key <PRSC> {
      # we can change this, ISO_Next_Group is bound to ctrl+alt+pgdn
      type= "ONE_LEVEL",
      symbols[Group1]=[ISO_Next_Group]
    };
    key <MUTE> {[ XF86AudioMute        ]};
    key <VOL-> {[ XF86AudioLowerVolume ]};
    key <VOL+> {[ XF86AudioRaiseVolume ]};
    key <PAUS> {
      type= "CONTROL",
      symbols[Group1]= [ Pause, Break ]
    };
    key <I151> {[ XF86WakeUp            ]};
    key <SNIP> {[ XF86Launch2           ]};
    key <STAR> {[ XF86Favorites         ]};
    key <MCMT> {[ XF86AudioMicMute      ]};
    key <FRSH> {[ XF86Launch3           ]};
    key <BRT-> {[ XF86MonBrightnessDown ]};
    key <BRT+> {[ XF86MonBrightnessUp   ]};
    key <DISP> {[ XF86Display           ]};

    modifier_map Control { <LCTL> };
    modifier_map Control { <RCTL> };
    modifier_map Control { <CAPS> };

    modifier_map Shift { <LFSH> };
    modifier_map Shift { <RTSH> };

    modifier_map Mod1 { <LALT> };
    modifier_map Mod4 { <LWIN> };

    # ------------------------------------------------------
    #                     number row                       #
    # ------------------------------------------------------

    # -- ` 1234567890 -= <BSKP> ------------------------------------------------
    #
    # -- 49(`),10-22(1-0,-,=)

    # note that dead keys need to be configured in XCompose
    # beware that the key.type sets the default for all keys below
    key.type = "EIGHT_LEVEL";

    key <BKTK> {[ grave, asciitilde                       ]}; # `~

    key <NUM1> {[ 1, exclam     , exclamdown, notsign     ]}; # 1!¡
    key <NUM2> {[ 2, at         , paragraph , section     ]}; # 2@¶§
    key <NUM3> {[ 3, numbersign , sterling  , VoidSymbol      # 3#£ ♯♭
                , musicalsharp, musicalflat               ]};
    key <NUM4> {[ 4, dollar     , EuroSign  , VoidSymbol  ]}; # 4$€
    key <NUM5> {[ 5, percent    , currency  , VoidSymbol      # 5%¤
                , VoidSymbol, permille ]};
    key <NUM6> {[ 6, asciicircum                          ]}; # 6^
    key <NUM7> {[ 7, ampersand                            ]}; # 7&
    key <NUM8> {[ 8, asterisk                             ]}; # 8*
    key <NUM9> {[ 9, parenleft  , VoidSymbol, VoidSymbol      # 9( ‘
                , leftsinglequotemark  ]};
    key <NUM0> {[ 0, parenright , degree    , numerosign      # 0)°№’
                , rightsinglequotemark ]};

    key <MNUS> {
      [ bracketleft, braceleft , onefifth  , leftdoublequotemark ],
      # -,_,–,—,
      [ minus      , underscore, endash    , emdash              ]
    };
    key <EQUL> {
      [ bracketright, braceright, guillemotright , rightdoublequotemark],
      # =+×÷±≠†‡
      [ equal    , plus    , multiply, division
      , plusminus, notequal, dagger  , doubledagger  ]
    };


    # diacritics (dead keys):
    # acute      : á   # '
    # grave      : à   # `
    # tilde      : ã   # ~
    # circumflex : â   # ^
    # cedilla    : ç   # ,
    # abovering  : å   # 0
    # diaeresis  : ä   # "
    # stroke     : ⱥ   # /
    # doubleacute: ő   # ''
    # abovedot   : ȧ   # :
    # belowdot   : ạ   # ;

    # ?=+\|!@#$%&*(){}[]-_
    # breve      : ă   # ?
    # caron      : ǎ   # ?
    # hook       : ả   # ?
    # horn       : ơ   # ?
    # ogonek     : ą   # ?

    # ------------------------------------------------------
    #                     letter rows                      #
    # ------------------------------------------------------

    # beware that the key.type sets the default for all keys below
    key.type="EIGHT_LEVEL_ALPHABETIC";

    # the general alpha map is:
    # lowercase, uppercase, lower-greek, upper-greek, ?, BlackBoard Bold, ?, ?

    # -- first letter row --------------

    # note that dead keys need to be configured in XCompose
    key <KP_Q> {
      # ',",„
      [ apostrophe, quotedbl, doublelowquotemark  ],
      # q,Q,θ,Θ,,ℚ
      [ q         , Q       , Greek_theta, Greek_THETA   , VoidSymbol, U211A ]
    };
    key <KP_W> {
      # ,<«
      [ comma     , less               , guillemotleft   , VoidSymbol
      , VoidSymbol, filledlefttribullet, enfilledsqbullet, enopensquarebullet ],
      # w,W,ω,Ω,,𝕎
      [ w    , W   , Greek_omega  , Greek_OMEGA, VoidSymbol, U1D54E ]
    };
    key <KP_E> {
      # .,>,»,·,…,▶,•,◦
      [ period, greater, guillemotright, periodcentered,
        ellipsis, filledrighttribullet, enfilledcircbullet, enopencircbullet ],
      # e,E,ε,,,𝔼 # greek capital Epsilon is indistinguishable from 'E'
      [ e     , E      , Greek_epsilon , VoidSymbol   , VoidSymbol, U1D53C ]
    };
    key <KP_R> {
      # p,P,π,Π,℗,ℙ
      [ p, P, Greek_pi , Greek_PI  , phonographcopyright, U2119 ],
      # r,R,ρ,,®,ℝ,™ # greek capital Rho is indistinguishable from 'P'
      [ r, R, Greek_rho, VoidSymbol, registered         , U211D, trademark  ]
    };
    key <KP_T> {
      # y,Y,ψ,Ψ,¥,ℙ,✓
      [ y, Y, Greek_psi, Greek_PSI , yen  , U1D550, checkmark        ],
      # t,T,τ,,™,𝕋,þ,Þ # greek capital Tau is indistinguishable from 'T'
      [ t, T, Greek_tau, VoidSymbol, trademark, U1D54B, thorn, THORN ]
    };
    key <KP_Y> {
      # f,F,,,,𝔽
      [ f, F, VoidSymbol, VoidSymbol, VoidSymbol, U1D53D ],
      # y,Y,ψ,Ψ,¥,ℙ, ✓
      [ y, Y, Greek_psi , Greek_PSI , yen, U1D550, checkmark ]
    };
    key <KP_U> {
      # g,G,γ,Γ,,𝔾
      [ g, G, Greek_gamma  , Greek_GAMMA, VoidSymbol, U1D53E ],
      # greek capital Upsilon is indistinguishable from 'U'
      [ u, U, Greek_upsilon, VoidSymbol , VoidSymbol, U1D54C ]
    };
    key <KP_I> {
      # c,C,χ,,©,ℂ,¢ # greek capital Chi is indistinguishable from 'X'
      [ c, C, Greek_chi , VoidSymbol, copyright , U2102, cent ],
      # i,I,ι,,,𝕀 # greek capital Iota is indistinguishable from 'I'
      [ i, I, Greek_iota, VoidSymbol, VoidSymbol, U1D540      ]
    };
    key <KP_O> {
      # r,R,ρ,,®,ℝ,™ # greek capital Rho is indistinguishable from 'P'
      [ r, R, Greek_rho, VoidSymbol, registered, U211D, trademark ],
      # greek omicron is indistinguishable from 'o'
      # U1D546 is blackboard-bold O
      [ o, O, VoidSymbol, VoidSymbol, VoidSymbol, U1D546 ]
    };
    key <KP_P> {
      # l,L,λ,Λ,,𝕃
      [ l, L, Greek_lambda, Greek_LAMBDA, VoidSymbol         , U1D543 ],
      # p,P,π,Π,℗,ℙ
      [ p, P, Greek_pi    , Greek_PI    , phonographcopyright, U2119 ]
    };
    key <LBRK> {
      # /?¿
      [ slash      , question , VoidSymbol, questiondown       , VoidSymbol ],
      # [{“
      [ bracketleft, braceleft, VoidSymbol   , leftdoublequotemark ]
    };

    key <RBRK> {
      # =+×÷±≠†‡
      [ equal    , plus    , multiply, division
      , plusminus, notequal, dagger  , doubledagger  ],
      # ]}”
      [ bracketright, braceright, VoidSymbol, rightdoublequotemark ]
    };

    # -- second letter row -------------

    # a,A,α,,ҩ,𝔸 # Cyrillic small Abkhasian-ha
    key <KP_A> {[ a, A, Greek_alpha, VoidSymbol, U04A9, U1D538  ]};

    key <KP_S> {
      # greek omicron is indistinguishable from 'o'
      # U1D546 is blackboard-bold O
      # o, O,,,, 𝕆
      [ o, O, VoidSymbol, VoidSymbol, VoidSymbol, U1D546 ],
      # s,S,σ,Σ,ß,𝕊,,ς
      [ s     , S     , Greek_sigma, Greek_SIGMA
      , ssharp, U1D54A, VoidSymbol , Greek_finalsmallsigma ]
    };
    key <KP_D> {
      # e,E,ε,,,𝔼 # greek capital Epsilon is indistinguishable from 'E'
      [ e, E, Greek_epsilon , VoidSymbol , VoidSymbol, U1D53C           ],
      # d,D,δ,Δ,,𝔻,ð,Ð
      [ d, D, Greek_delta,    Greek_DELTA, VoidSymbol, U1D53B, eth, ETH ]
    };
    key <KP_F> {
      # u,U,υ,,,𝕌 # greek capital Upsilon is indistinguishable from 'U'
      [ u, U, Greek_upsilon, VoidSymbol, VoidSymbol, U1D54C ],
      # f,F,,,,𝔽
      [ f, F, VoidSymbol   , VoidSymbol, VoidSymbol, U1D53D ]
    };
    key <KP_G> {
      # i,I,ι,,,𝕀 # greek capital Iota is indistinguishable from 'I'
      [ i, I, Greek_iota , VoidSymbol , VoidSymbol, U1D540 ],
      # g,G,γ,Γ,,𝔾
      [ g, G, Greek_gamma, Greek_GAMMA, VoidSymbol, U1D53E ]
    };
    key <KP_H> {
      # d,D,δ,Δ,,𝔻,ð,Ð
      [ d, D, Greek_delta,    Greek_DELTA, VoidSymbol, U1D53B, eth, ETH ],
      # greek capital Eta is indistinguishable from 'H'
      [ h, H, Greek_eta, VoidSymbol, VoidSymbol, U210D ]
    };
    key <KP_J> {
      # h,H,η,,,ℍ # greek capital Eta is indistinguishable from 'H'
      [ h, H, Greek_eta, VoidSymbol, VoidSymbol, U210D  ],
      # j,J,φ,Φ,,𝕁
      [ j, J, Greek_phi, Greek_PHI , VoidSymbol, U1D541 ]
    };
    key <KP_K> {
      # t,T,τ,,™,𝕋,þ,Þ # greek capital Tau is indistinguishable from 'T'
      [ t, T, Greek_tau, VoidSymbol, trademark, U1D54B, thorn, THORN ],
      # k,K,κ,,,𝕂 # greek capital Kappa is indistinguishable from 'K'
      [ k, K, Greek_kappa, VoidSymbol, VoidSymbol, U1D542        ]
    };
    key <KP_L> {
      # n,N,ν,,,ℕ # greek capital Nu is indistinguishable from 'N'
      [ n, N, Greek_nu    , VoidSymbol  , VoidSymbol, U2115  ],
      # l,L,λ,Λ,,𝕃
      [ l, L, Greek_lambda, Greek_LAMBDA, VoidSymbol, U1D543 ]
    };
    key <SEMI> {
      # s,S,σ,Σ,ß,𝕊,,ς
      [ s     , S     , Greek_sigma, Greek_SIGMA
      , ssharp, U1D54A, VoidSymbol , Greek_finalsmallsigma ],
      # ;:
      [ semicolon, colon              ]
    };
    key <APOS> {
      # -,_,–,—,
      [ minus     , underscore , endash            , emdash     ],
      # ',",„
      [ apostrophe, quotedbl   , doublelowquotemark             ]
    };
    key <HASH> {
      # \|¬
      type[Group1]    = "EIGHT_LEVEL_ALPHABETIC",
      symbols[Group1] = [ backslash, bar, notsign, brokenbar ],

      type[Group2]    = "CTRL-ALT",
      symbols[Group2] = [ VoidSymbol, Multi_key ],
      # don't (e.g.) hyper_* here, as then emacs reads that as Hyper modifier
      actions[Group2] = [ SetMods(modifiers=Mod3,clearLocks) ]
    };

    # -- third letter row --------------

    key <BKSL> {
      type[Group1]    = "CTRL-ALT",
      symbols[Group1] = [ NoSymbol, Multi_key ],
      # don't (e.g.) hyper_* here, as then emacs reads that as Hyper modifier
      actions[Group1] = [ SetMods(modifiers=Mod3,clearLocks) ],
      type[Group2]    = "EIGHT_LEVEL_ALPHABETIC",
      symbols[Group2] = [ backslash, bar, notsign, brokenbar ]
    };
    key <KP_Z> {
      # ;:¶°
      [ semicolon, colon, paragraph, degree ],
      # z,Z,ζ,,,ℤ # greek capital Zeta is indistinguishable from 'Z'
      [ z, Z, Greek_zeta, VoidSymbol, VoidSymbol, U2124 ]
    };
    key <KP_X> {
      # q,Q,θ,Θ,,ℚ
      [ q, Q, Greek_theta, Greek_THETA, VoidSymbol, U211A ],
      # x,X,ξ,Ξ,,𝕏,☓
      [ x, X, Greek_xi, Greek_XI, VoidSymbol, U1D54F, signaturemark ]
    };
    key <KP_C> {
      # j,J,φ,Φ,,𝕁
      [ j, J, Greek_phi, Greek_PHI , VoidSymbol, U1D541 ],
      # c,C,χ,,©,ℂ,¢ # greek capital Chi is indistinguishable from 'X'
      [ c, C, Greek_chi , VoidSymbol, copyright , U2102, cent ]
    };
    key <KP_V> {
      # k,K,κ,,,𝕂 # greek capital Kappa is indistinguishable from 'K'
      [ k, K, Greek_kappa, VoidSymbol, VoidSymbol, U1D542 ],
      # v,V,,,,𝕍
      [ v, V, VoidSymbol , VoidSymbol, VoidSymbol, U1D54D ]
    };
    key <KP_B> {
      # x,X,ξ,Ξ,,𝕏,☓
      [ x, X, Greek_xi  , Greek_XI  , VoidSymbol, U1D54F, signaturemark ],
      # b,B,β,,,𝔹 # greek capital Beta is indistinguishable from 'N'
      [ b, B, Greek_beta, VoidSymbol, VoidSymbol, U1D539 ]
    };
    key <KP_N> {
      # b,B,β,,,𝔹 # greek capital Beta is indistinguishable from 'N'
      [ b, B, Greek_beta, VoidSymbol, VoidSymbol, U1D539 ],
      # n,N,ν,,,ℕ # greek capital Nu is indistinguishable from 'N'
      [ n, N, Greek_nu  , VoidSymbol, VoidSymbol, U2115  ]
    };
    key <KP_M> {
      # m,M,μ,,,𝕄
      [ m, M, Greek_mu, VoidSymbol, VoidSymbol, U1D544 ]
    };
    key <COMM> {
      # w,W,ω,Ω,,𝕎
      [ w    , W   , Greek_omega  , Greek_OMEGA, VoidSymbol, U1D54E ],
      # ,<«  ◀▪▫
      [ comma     , less               , guillemotleft   , VoidSymbol
      , VoidSymbol, filledlefttribullet, enfilledsqbullet, enopensquarebullet ]
    };
    key <PERD> {
      # v,V,,,,𝕍
      [ v, V, VoidSymbol, VoidSymbol, VoidSymbol, U1D54D ],
      # .,>,»,·,…,▶,•,◦
      [ period, greater, guillemotright, periodcentered,
        ellipsis, filledrighttribullet, enfilledcircbullet, enopencircbullet ]
    };
    key <SLSH> {
      # z,Z,ζ,,,ℤ # greek capital Zeta is indistinguishable from 'Z'
      [ z,     Z,        Greek_zeta,  VoidSymbol  , VoidSymbol, U2124 ],
      # /?¿
      [ slash, question, VoidSymbol, questiondown, VoidSymbol ]
    };
  };

};

# Local Variables:
# fill-column: 132
# End:
