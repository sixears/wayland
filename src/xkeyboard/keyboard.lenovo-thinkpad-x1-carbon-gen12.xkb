# https://wiki.archlinux.org/title/Xorg/Keyboard_configuration
# https://wiki.archlinux.org/title/X_keyboard_extension
# https://who-t.blogspot.com/2020/02/user-specific-xkb-configuration-part-1.html

# To output current map: xkbcomp $DISPLAY -
# see also xkb-file (executable)

# In principle, you can reload a file with xkbcomp FILENAME $DISPLAY; but this
# probably won't work appropriately on wayland; use sway-reload for that

# https://github.com/swaywm/sway/issues/5461
# if in doubt, compile this file with `xkbcomp FILE $DISPLAY`
# (xkbcomp is from xorg.xkbcomp)
# e.g., sway may reload happily, but emacs will bork (and probably revert to the
# hard keyboard, i.e., qwerty)

xkb_keymap {
  xkb_keycodes {
    minimum = 8;
    maximum = 255;

    # --------------------------------------------------------

    <ESC>  =   9;
    <FK01> =  67;
    <FK02> =  68;
    <FK03> =  69;
    <FK04> =  70;
    <FK05> =  71;
    <FK06> =  72;
    <FK07> =  73;
    <FK08> =  74;
    <FK09> =  75;
    <FK10> =  76;
    <FK11> =  95;
    <FK12> =  96;

    # ------------------------------------

    <HOME> = 110;
    <END>  = 115;
    <INS>  = 118;
    <DELE> = 119;

    # --------------------------------------------------------

    <MUTE> = 121; # Fn+FK1
    <VOL-> = 122; # Fn+FK2
    <VOL+> = 123; # Fn+FK3
    <MCMT> = 198; # Fn+FK4: Mic Mute
    <BRT-> = 232; # Fn+FK5: Brightness Down
    <BRT+> = 233; # Fn+FK6: Brightness Up
    <DISP> = 235; # Fn+FK7: Display
    # No key code for Fn+FK8
    <PRSC> = 107; # Fn+FK9
    <SNIP> = 157; # Fn+FK10
    # No key code for Fn+FK11
    <STAR> = 164; # Fn+FK12

    # --------------------------------------------------------

    <BKTK> =  49; # Backtick
    <NUM1> =  10;
    <NUM2> =  11;
    <NUM3> =  12;
    <NUM4> =  13;
    <NUM5> =  14;
    <NUM6> =  15;
    <NUM7> =  16;
    <NUM8> =  17;
    <NUM9> =  18;
    <NUM0> =  19;
    <MNUS> =  20;
    <EQUL> =  21;
    <BKSP> =  22;

    # --------------------------------------------------------

    <TAB>  =  23; <FTAB> = 380; # Fn+TAB
    <KP_Q> =  24;
    <KP_W> =  25;
    <KP_E> =  26;
    <KP_R> =  27;
    <KP_T> =  28;
    <KP_Y> =  29;
    <KP_U> =  30;
    <KP_I> =  31;
    <KP_O> =  32;
    <KP_P> =  33; <PAUS> = 127; # Fn+p
    <LBRK> =  34; # left bracket
    <RBRK> =  35; # right bracket

    # --------------------------------------------------------

    <CAPS> =  66;
    <KP_A> =  38;
    <KP_S> =  39;
    <KP_D> =  40;
    <KP_F> =  41;
    <KP_G> =  42;
    <KP_H> =  43;
    <KP_J> =  44;
    <KP_K> =  45; <SCLK> = 78; # Fn+k

    <KP_L> =  46;
    <SEMI> =  47; # semicolon
    <APOS> =  48; # apostrophe
    <HASH> =  51;
    <RTRN> =  36;

    # --------------------------------------------------------

    <LFSH> =  50; # left shift
    <BKSL> =  94;
    <KP_Z> =  52;
    <KP_X> =  53;
    <KP_C> =  54;
    <KP_V> =  55;
    <KP_B> =  56;
    <KP_N> =  57;
    <KP_M> =  58;
    <COMM> =  59; # comma
    <PERD> =  60; # period
    <SLSH> =  61; # slash
    <RTSH> =  62; <FRSH> = 210; # right shift; Fn+RShift

    # --------------------------------------------------------

    <LCTL> =  37;
    <I151> = 151;
    <LWIN> = 133;
    <LALT> =  64;
    <SPCE> =  65;
    <RALT> = 108;
    <RCTL> = 105;

    <PGUP> = 112;
    <UP>   = 111;
    <PGDN> = 117;
    <LEFT> = 113;
    <DOWN> = 116;
    <RGHT> = 114;

    # --------------------------------------------------------

    # where the indicator is; see xkb_compatibility/indicator for usage
     indicator 1 = "Caps Lock";
  };

  xkb_types "(unnamed)" {
    # modifier bits:
    # 01 - Shift
    # 02 - Lock (as in CapsLock)
    # 04 - Control
    # 08 - Mod1 (Alt/Meta)
    # 40 - Mod4
    # 80 - Mod5 (LevelThree)

    virtual_modifiers NumLock,Alt,LevelThree,LevelFive,Meta,Super,Hyper,ScrollLock;

    type "ONE_LEVEL" {
        modifiers= none;
        level_name[Level1]= "Any";
    };
    type "TWO_LEVEL" {
        modifiers= Shift;
        map[Shift]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift";
    };
    type "PC_CONTROL_LEVEL2" {
        modifiers= Control;
        map[Control]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Control";
    };
    type "CTRL-ALT" {
      # ignore control, alt individually: react only to ctrl+alt together
      modifiers= Control+Mod1;
      map[Control+Mod1]=Level2;
    };
    type "CTRL+ALT" {
        modifiers= Control+Mod1;
        map[Control]=Level2;
        map[Mod1]=Level3;
        map[Control+Mod1]=Level4;
    };
    type "FOUR_LEVEL" {
      # the levels are:
      # 0: unmolested
      # 1: shift
      # 2: mod5(ralt)
      # 3: mod5(ralt)+shift

      modifiers          = Shift+Mod5;
      map[Shift]         = Level2;
      map[Mod5]          = Level3;
      map[Shift+Mod5]    = Level4;
      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
      level_name[Level3] = "AltGr";
      level_name[Level4] = "Shift AltGr";
    };
    type "FOUR_LEVEL_ALPHABETIC" {
      # like four-level, but respecting caps-lock also

      # this (modifiers) needs to co-ordinate with the relevant map[..], but
      # also the interpret actions
      modifiers= Shift+Lock+Mod5;

      map[Shift]           = Level2;
      map[Lock]            = Level2;
      map[Mod5]            = Level3;
      map[Shift+Mod5]      = Level4;
      map[Lock+Mod5]       = Level4;
      map[Shift+Lock+Mod5] = Level4;

      # per https://wiki.archlinux.org/title/X_keyboard_extension#xkb_types
      #
      #     level_name lines are irrelevant and can be ignored.
      #
      # however, in practice, vlc failed to respond to Ctrl keys and arrows when
      # these were commented out.
      level_name[Level1] = "Base";
      level_name[Level2] = "Shift";
      level_name[Level3] = "AltGr";
      level_name[Level4] = "Shift AltGr";
    };
    type "EIGHT_LEVEL" {
      # the levels are:
      # 0: unmolested
      # 1: shift
      # 2: mod5(ralt)
      # 3: mod5(ralt)+shift
      # 4: super(lwin)
      # 5: super(lwin)+shift
      # 6: super(lwin)+mod5(ralt)
      # 7: super(lwin)+mod5(ralt)+shift

      modifiers= Shift+Mod5+Mod4;
      map[Shift]= Level2;
      map[Mod5]= Level3;
      map[Shift+Mod5]= Level4;
      map[Mod4]= Level5;
      map[Shift+Mod4]= Level6;
      map[Mod5+Mod4]= Level7;
      map[Shift+Mod5+Mod4]= Level8;
      level_name[Level1]= "Base";
      level_name[Level2]= "Shift";
      level_name[Level3]= "AltGr";
      level_name[Level4]= "Shift AltGr";
      level_name[Level5]= "X";
      level_name[Level6]= "X Shift";
      level_name[Level7]= "X AltGr";
      level_name[Level8]= "X Shift AltGr";
    };
    type "EIGHT_LEVEL_ALPHABETIC" {
        modifiers                 = Shift+Lock+Mod5+Mod4;
        map[Shift]                = Level2;
        map[Lock]                 = Level2;
        map[Mod5]                 = Level3;
        map[Shift+Mod5]           = Level4;
        map[Lock+Mod5]            = Level4;
        map[Shift+Lock+Mod5]      = Level3;
        map[Mod4]                 = Level5;
        map[Shift+Mod4]           = Level6;
        map[Lock+Mod4]            = Level6;
        map[Shift+Lock+Mod4]      = Level5;
        map[Mod5+Mod4]            = Level7;
        map[Shift+Mod5+Mod4]      = Level8;
        map[Lock+Mod5+Mod4]       = Level8;
        map[Shift+Lock+Mod5+Mod4] = Level7;

        level_name[Level1] = "Base";
        level_name[Level2] = "Shift";
        level_name[Level3] = "AltGr";
        level_name[Level4] = "Shift AltGr";
        level_name[Level5] = "X";
        level_name[Level6] = "X Shift";
        level_name[Level7] = "X AltGr";
        level_name[Level8] = "X Shift AltGr";
    };
    type "EIGHT_LEVEL_SEMIALPHABETIC" {
        modifiers= Shift+Lock+LevelThree+LevelFive;
        map[Shift]= Level2;
        map[Lock]= Level2;
        map[LevelThree]= Level3;
        map[Shift+LevelThree]= Level4;
        map[Lock+LevelThree]= Level3;
        preserve[Lock+LevelThree]= Lock;
        map[Shift+Lock+LevelThree]= Level4;
        preserve[Shift+Lock+LevelThree]= Lock;
        map[LevelFive]= Level5;
        map[Shift+LevelFive]= Level6;
        map[Lock+LevelFive]= Level6;
        map[Shift+Lock+LevelFive]= Level5;
        map[LevelThree+LevelFive]= Level7;
        map[Shift+LevelThree+LevelFive]= Level8;
        map[Lock+LevelThree+LevelFive]= Level7;
        preserve[Lock+LevelThree+LevelFive]= Lock;
        map[Shift+Lock+LevelThree+LevelFive]= Level8;
        preserve[Shift+Lock+LevelThree+LevelFive]= Lock;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift";
        level_name[Level3]= "AltGr";
        level_name[Level4]= "Shift AltGr";
        level_name[Level5]= "X";
        level_name[Level6]= "X Shift";
        level_name[Level7]= "X AltGr";
        level_name[Level8]= "X Shift AltGr";
    };
    type "EIGHT_LEVEL_WITH_LEVEL5_LOCK" {
        modifiers= Shift+NumLock+LevelThree+LevelFive;
        map[Shift]= Level2;
        map[LevelThree]= Level3;
        map[Shift+LevelThree]= Level4;
        map[LevelFive]= Level5;
        map[Shift+LevelFive]= Level6;
        preserve[Shift+LevelFive]= Shift;
        map[LevelThree+LevelFive]= Level7;
        map[Shift+LevelThree+LevelFive]= Level8;
        map[NumLock]= Level5;
        map[Shift+NumLock]= Level6;
        preserve[Shift+NumLock]= Shift;
        map[NumLock+LevelThree]= Level7;
        map[Shift+NumLock+LevelThree]= Level8;
        map[Shift+NumLock+LevelFive]= Level2;
        map[NumLock+LevelThree+LevelFive]= Level3;
        map[Shift+NumLock+LevelThree+LevelFive]= Level4;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift";
        level_name[Level3]= "AltGr";
        level_name[Level4]= "Shift AltGr";
        level_name[Level5]= "X";
        level_name[Level6]= "X Shift";
        level_name[Level7]= "X AltGr";
        level_name[Level8]= "X Shift AltGr";
    };
    type "EIGHT_LEVEL_ALPHABETIC_WITH_LEVEL5_LOCK" {
        modifiers= Shift+Lock+NumLock+LevelThree+LevelFive;
        map[Shift]= Level2;
        map[LevelThree]= Level3;
        map[Shift+LevelThree]= Level4;
        map[LevelFive]= Level5;
        map[Shift+LevelFive]= Level6;
        preserve[Shift+LevelFive]= Shift;
        map[LevelThree+LevelFive]= Level7;
        map[Shift+LevelThree+LevelFive]= Level8;
        map[NumLock]= Level5;
        map[Shift+NumLock]= Level6;
        preserve[Shift+NumLock]= Shift;
        map[NumLock+LevelThree]= Level7;
        map[Shift+NumLock+LevelThree]= Level8;
        map[Shift+NumLock+LevelFive]= Level2;
        map[NumLock+LevelThree+LevelFive]= Level3;
        map[Shift+NumLock+LevelThree+LevelFive]= Level4;
        map[Lock]= Level2;
        map[Lock+LevelThree]= Level3;
        map[Shift+Lock+LevelThree]= Level4;
        map[Lock+LevelFive]= Level5;
        map[Shift+Lock+LevelFive]= Level6;
        map[Lock+LevelThree+LevelFive]= Level7;
        map[Shift+Lock+LevelThree+LevelFive]= Level8;
        map[Lock+NumLock]= Level5;
        map[Shift+Lock+NumLock]= Level6;
        map[Lock+NumLock+LevelThree]= Level7;
        map[Shift+Lock+NumLock+LevelThree]= Level8;
        map[Lock+NumLock+LevelFive]= Level2;
        map[Lock+NumLock+LevelThree+LevelFive]= Level3;
        map[Shift+Lock+NumLock+LevelThree+LevelFive]= Level4;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift";
        level_name[Level3]= "AltGr";
        level_name[Level4]= "Shift AltGr";
        level_name[Level5]= "X";
        level_name[Level6]= "X Shift";
        level_name[Level7]= "X AltGr";
        level_name[Level8]= "X Shift AltGr";
    };
    type "EIGHT_LEVEL_BY_CTRL" {
        modifiers= Shift+Lock+Control+LevelThree;
        map[Shift]= Level2;
        map[Lock]= Level2;
        map[LevelThree]= Level3;
        map[Shift+LevelThree]= Level4;
        map[Lock+LevelThree]= Level4;
        map[Shift+Lock+LevelThree]= Level3;
        map[Control]= Level5;
        map[Shift+Control]= Level6;
        map[Lock+Control]= Level6;
        map[Shift+Lock+Control]= Level5;
        map[Control+LevelThree]= Level7;
        map[Shift+Control+LevelThree]= Level8;
        map[Lock+Control+LevelThree]= Level8;
        map[Shift+Lock+Control+LevelThree]= Level7;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift";
        level_name[Level3]= "Level3";
        level_name[Level4]= "Shift Level3";
        level_name[Level5]= "Ctrl";
        level_name[Level6]= "Shift Ctrl";
        level_name[Level7]= "Level3 Ctrl";
        level_name[Level8]= "Shift Level3 Ctrl";
    };
    type "SHIFT+ALT" {
        modifiers= Shift+Alt;
        map[Shift+Alt]= Level2;
        level_name[Level1]= "Base";
        level_name[Level2]= "Shift+Alt";
    };
  };

xkb_compatibility "(unnamed)" {

  # SetMods makes a regular "on while pressed" modifier key. LockMods makes an
  # "on/off" switch like CapsLock or NumLock. LatchMods means "on until next
  # keypress" aka sticky modifier.

  # from https://wiki.archlinux.org/title/X_keyboard_extension#xkb_compatibility :
  #
  # Warning: four standard types, ONE_LEVEL, TWO_LEVEL, ALPHABETIC and KEYPAD,
  # receive special treatment in xkbcomp(1). They may work differently just
  # because they are named this way. Avoid deleting them. If some changes do not
  # work as expected, try adding a new type instead.

    virtual_modifiers NumLock,Alt,LevelThree,LevelFive,Meta,Super,Hyper,ScrollLock;

    interpret.useModMapMods= AnyLevel;
    interpret.repeat= False;
    interpret.locking= False;
    interpret ISO_Level2_Latch+Exactly(Shift) {
        useModMapMods=level1;
        action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
    };
    interpret Shift_Lock+AnyOf(Shift+Lock) {
        action= LockMods(modifiers=Shift);
    };
    interpret Num_Lock+AnyOf(all) {
        virtualModifier= NumLock;
        action= LockMods(modifiers=NumLock);
    };
    interpret ISO_Level3_Shift+AnyOf(all) {
##        virtualModifier= LevelThree;
##        useModMapMods=level1;
##        action= SetMods(modifiers=LevelThree,clearLocks);
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret ISO_Level3_Latch+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LockMods(modifiers=LevelThree);
    };
    interpret Alt_L+AnyOf(all) {
        virtualModifier= Alt;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Alt_R+AnyOf(all) {
        virtualModifier= Alt;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Meta_L+AnyOf(all) {
        virtualModifier= Meta;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Meta_R+AnyOf(all) {
        virtualModifier= Meta;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Super_L+AnyOf(all) {
        virtualModifier= Super;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Super_R+AnyOf(all) {
        virtualModifier= Super;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Hyper_L+AnyOf(all) {
        virtualModifier= Hyper;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret Hyper_R+AnyOf(all) {
        virtualModifier= Hyper;
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    interpret ISO_Level5_Shift+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= SetMods(modifiers=LevelFive,clearLocks);
    };
    interpret ISO_Level5_Latch+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= LatchMods(modifiers=LevelFive,clearLocks,latchToLock);
    };
    interpret ISO_Level5_Lock+AnyOf(all) {
        virtualModifier= LevelFive;
        useModMapMods=level1;
        action= LockMods(modifiers=LevelFive);
    };

    # Note that key+AnyOfOrNone(all) is equivalent to just key, but key is much
    # easier to read.
    interpret Mode_switch {
        action= SetGroup(group=+1);
    };
    interpret ISO_Level3_Shift {
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret ISO_Level3_Latch {
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock {
        action= LockMods(modifiers=LevelThree);
    };
    interpret ISO_Group_Latch {
        action= LatchGroup(group=2);
    };
    interpret ISO_Next_Group {
        action= LockGroup(group=+1);
    };
    interpret ISO_Prev_Group {
        action= LockGroup(group=-1);
    };
    interpret ISO_First_Group {
        action= LockGroup(group=1);
    };
    interpret ISO_Last_Group {
        action= LockGroup(group=2);
    };
    interpret KP_1 {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret KP_End {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret KP_2 {
        repeat= True;
        action= MovePtr(x=+0,y=+1);
    };
    interpret KP_Down {
        repeat= True;
        action= MovePtr(x=+0,y=+1);
    };
    interpret KP_3 {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret KP_Next {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret KP_4 {
        repeat= True;
        action= MovePtr(x=-1,y=+0);
    };
    interpret KP_Left {
        repeat= True;
        action= MovePtr(x=-1,y=+0);
    };
    interpret KP_6 {
        repeat= True;
        action= MovePtr(x=+1,y=+0);
    };
    interpret KP_Right {
        repeat= True;
        action= MovePtr(x=+1,y=+0);
    };
    interpret KP_7 {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret KP_Home {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret KP_8 {
        repeat= True;
        action= MovePtr(x=+0,y=-1);
    };
    interpret KP_Up {
        repeat= True;
        action= MovePtr(x=+0,y=-1);
    };
    interpret KP_9 {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret KP_Prior {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret KP_5 {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret KP_Begin {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret KP_F2 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret KP_Divide {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret KP_F3 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret KP_Multiply {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret KP_F4 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=3);
    };
    interpret KP_Subtract {
        repeat= True;
        action= SetPtrDflt(affect=button,button=3);
    };
    interpret KP_Separator {
        repeat= True;
        action= PtrBtn(button=default,count=2);
    };
    interpret KP_Add {
        repeat= True;
        action= PtrBtn(button=default,count=2);
    };
    interpret KP_0 {
        repeat= True;
        action= LockPtrBtn(button=default,affect=lock);
    };
    interpret KP_Insert {
        repeat= True;
        action= LockPtrBtn(button=default,affect=lock);
    };
    interpret KP_Decimal {
        repeat= True;
        action= LockPtrBtn(button=default,affect=unlock);
    };
    interpret KP_Delete {
        repeat= True;
        action= LockPtrBtn(button=default,affect=unlock);
    };
    interpret F25 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=1);
    };
    interpret F26 {
        repeat= True;
        action= SetPtrDflt(affect=button,button=2);
    };
    interpret F27 {
        repeat= True;
        action= MovePtr(x=-1,y=-1);
    };
    interpret F29 {
        repeat= True;
        action= MovePtr(x=+1,y=-1);
    };
    interpret F31 {
        repeat= True;
        action= PtrBtn(button=default);
    };
    interpret F33 {
        repeat= True;
        action= MovePtr(x=-1,y=+1);
    };
    interpret F35 {
        repeat= True;
        action= MovePtr(x=+1,y=+1);
    };
    interpret Pointer_Button_Dflt {
        action= PtrBtn(button=default);
    };
    interpret Pointer_Button1 {
        action= PtrBtn(button=1);
    };
    interpret Pointer_Button2 {
        action= PtrBtn(button=2);
    };
    interpret Pointer_Button3 {
        action= PtrBtn(button=3);
    };
    interpret Pointer_DblClick_Dflt {
        action= PtrBtn(button=default,count=2);
    };
    interpret Pointer_DblClick1 {
        action= PtrBtn(button=1,count=2);
    };
    interpret Pointer_DblClick2 {
        action= PtrBtn(button=2,count=2);
    };
    interpret Pointer_DblClick3 {
        action= PtrBtn(button=3,count=2);
    };
    interpret Pointer_Drag_Dflt {
        action= LockPtrBtn(button=default,affect=both);
    };
    interpret Pointer_Drag1 {
        action= LockPtrBtn(button=1,affect=both);
    };
    interpret Pointer_Drag2 {
        action= LockPtrBtn(button=2,affect=both);
    };
    interpret Pointer_Drag3 {
        action= LockPtrBtn(button=3,affect=both);
    };
    interpret Pointer_EnableKeys {
        action= LockControls(controls=MouseKeys);
    };
    interpret Pointer_Accelerate {
        action= LockControls(controls=MouseKeysAccel);
    };
    interpret Pointer_DfltBtnNext {
        action= SetPtrDflt(affect=button,button=+1);
    };
    interpret Pointer_DfltBtnPrev {
        action= SetPtrDflt(affect=button,button=-1);
    };
    interpret AccessX_Enable {
        action= LockControls(controls=AccessXKeys);
    };
    interpret AccessX_Feedback_Enable {
        action= LockControls(controls=AccessXFeedback);
    };
    interpret RepeatKeys_Enable {
        action= LockControls(controls=RepeatKeys);
    };
    interpret SlowKeys_Enable {
        action= LockControls(controls=SlowKeys);
    };
    interpret BounceKeys_Enable {
        action= LockControls(controls=BounceKeys);
    };
    interpret StickyKeys_Enable {
        action= LockControls(controls=StickyKeys);
    };
    interpret MouseKeys_Enable {
        action= LockControls(controls=MouseKeys);
    };
    interpret MouseKeys_Accel_Enable {
        action= LockControls(controls=MouseKeysAccel);
    };
    interpret Overlay1_Enable {
        action= LockControls(controls=none);
    };
    interpret Overlay2_Enable {
        action= LockControls(controls=none);
    };
    interpret AudibleBell_Enable {
        action= LockControls(controls=AudibleBell);
    };
    interpret Terminate_Server {
        action= Terminate();
    };
    interpret Alt_L {
        action= SetMods(modifiers=Alt,clearLocks);
    };
    interpret Alt_R {
        action= SetMods(modifiers=Alt,clearLocks);
    };
    interpret Meta_L {
        action= SetMods(modifiers=Meta,clearLocks);
    };
    interpret Meta_R {
        action= SetMods(modifiers=Meta,clearLocks);
    };
    interpret Super_L {
        action= SetMods(modifiers=Super,clearLocks);
    };
    interpret Super_R {
        action= SetMods(modifiers=Super,clearLocks);
    };
    interpret Hyper_L {
        action= SetMods(modifiers=Hyper,clearLocks);
    };
    interpret Hyper_R {
#        action= SetMods(modifiers=Hyper,clearLocks);
        action= SetMods(modifiers=Mod5,clearLocks);
    };
    interpret Shift_L {
        action= SetMods(modifiers=Shift,clearLocks);
    };
    interpret Shift_R {
        action= SetMods(modifiers=Shift,clearLocks);
    };
    interpret XF86Switch_VT_1 {
        repeat= True;
        action= SwitchScreen(screen=1,!same);
    };
    interpret XF86Switch_VT_2 {
        repeat= True;
        action= SwitchScreen(screen=2,!same);
    };
    interpret XF86Switch_VT_3 {
        repeat= True;
        action= SwitchScreen(screen=3,!same);
    };
    interpret XF86Switch_VT_4 {
        repeat= True;
        action= SwitchScreen(screen=4,!same);
    };
    interpret XF86Switch_VT_5 {
        repeat= True;
        action= SwitchScreen(screen=5,!same);
    };
    interpret XF86Switch_VT_6 {
        repeat= True;
        action= SwitchScreen(screen=6,!same);
    };
    interpret XF86Switch_VT_7 {
        repeat= True;
        action= SwitchScreen(screen=7,!same);
    };
    interpret XF86Switch_VT_8 {
        repeat= True;
        action= SwitchScreen(screen=8,!same);
    };
    interpret XF86Switch_VT_9 {
        repeat= True;
        action= SwitchScreen(screen=9,!same);
    };
    interpret XF86Switch_VT_10 {
        repeat= True;
        action= SwitchScreen(screen=10,!same);
    };
    interpret XF86Switch_VT_11 {
        repeat= True;
        action= SwitchScreen(screen=11,!same);
    };
    interpret XF86Switch_VT_12 {
        repeat= True;
        action= SwitchScreen(screen=12,!same);
    };
    interpret XF86LogGrabInfo {
        repeat= True;
        action= Private(type=0x86,data[0]=0x50,data[1]=0x72,data[2]=0x47,data[3]=0x72,data[4]=0x62,data[5]=0x73,data[6]=0x00);
    };
    interpret XF86LogWindowTree {
        repeat= True;
        action= Private(type=0x86,data[0]=0x50,data[1]=0x72,data[2]=0x57,data[3]=0x69,data[4]=0x6e,data[5]=0x73,data[6]=0x00);
    };
    interpret XF86Next_VMode {
        repeat= True;
        action= Private(type=0x86,data[0]=0x2b,data[1]=0x56,data[2]=0x4d,data[3]=0x6f,data[4]=0x64,data[5]=0x65,data[6]=0x00);
    };
    interpret XF86Prev_VMode {
        repeat= True;
        action= Private(type=0x86,data[0]=0x2d,data[1]=0x56,data[2]=0x4d,data[3]=0x6f,data[4]=0x64,data[5]=0x65,data[6]=0x00);
    };
    interpret ISO_Level5_Shift {
        action= SetMods(modifiers=LevelFive,clearLocks);
    };
    interpret ISO_Level5_Latch {
        action= LatchMods(modifiers=LevelFive,clearLocks,latchToLock);
    };
    interpret ISO_Level5_Lock {
        action= LockMods(modifiers=LevelFive);
    };
    interpret Caps_Lock {
        action= LockMods(modifiers=Lock);
    };
    interpret Any+Exactly(Lock) {
        action= LockMods(modifiers=Lock);
    };
    interpret Any+AnyOf(all) {
        action= SetMods(modifiers=modMapMods,clearLocks);
    };
    indicator "Caps Lock" {
#        whichModState= Locked;
#        modifiers= Lock;
        whichModState= Any;
        modifiers= Mod5;
    };
};

xkb_symbols "lenovo thinkpad X1 carbon Gen12" {
            # used, e.g., on the lock screen
  name[1]="English (UK, dvorak, F12, bottom-left backslash, w/ dead keys)";
  name[2]="English (UK, qwerty, F12, bottom-left backslash, w/ dead keys)";

  # --  <ESC> F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 <HOME> <END> <INS> <DEL> --
  #
  # -- 9(ESC),67-76(F1-F10),95-96(F11-F12),110(HOME),115(END),118(INS),119(DEL)

  # 121-123(Fn+F1-Fn+F3),198(Fn+F4),232(Fn+F5),233(Fn+F6),
  # 235(Fn+F7),NOTHING(Fn+F8),107(Fn+F9),157(Fn+F10),NOTHING(Fn+F11),164(Fn+F12)
  #
  # Fn+p: 127
  # Fn+TAB: 380
  # Fn+s: 64+107
  # Fn+k: 78
  # Fn+RShft: 210
  # Fn+B: 37+127
  # Fn+LShft: 50 (same as LShft)
  # Fn+Left:110
  # Fn+Right:115


  key <ESC>  { [ Escape ] };
  key <FK01> { type= "CTRL-ALT", symbols[Group1]= [ F1,  XF86Switch_VT_1  ] };
  key <FK02> { type= "CTRL-ALT", symbols[Group1]= [ F2,  XF86Switch_VT_2  ] };
  key <FK03> { type= "CTRL-ALT", symbols[Group1]= [ F3,  XF86Switch_VT_3  ] };
  key <FK04> { type= "CTRL-ALT", symbols[Group1]= [ F4,  XF86Switch_VT_4  ] };
  key <FK05> { type= "CTRL-ALT", symbols[Group1]= [ F5,  XF86Switch_VT_5  ] };
  key <FK06> { type= "CTRL-ALT", symbols[Group1]= [ F6,  XF86Switch_VT_6  ] };
  key <FK07> { type= "CTRL-ALT", symbols[Group1]= [ F7,  XF86Switch_VT_7  ] };
  key <FK08> { type= "CTRL-ALT", symbols[Group1]= [ F8,  XF86Switch_VT_8  ] };
  key <FK09> { type= "CTRL-ALT", symbols[Group1]= [ F9,  XF86Switch_VT_9  ] };
  key <FK10> { type= "CTRL-ALT", symbols[Group1]= [ F10, XF86Switch_VT_10 ] };
  key <FK11> { type= "CTRL-ALT", symbols[Group1]= [ F11, XF86Switch_VT_11 ] };
  key <FK12> { type= "CTRL-ALT", symbols[Group1]= [ F12, XF86Switch_VT_12 ] };

  key <HOME> { [ Home   ] };
  key <END>  { [ End    ] };
  key <INS>  { [ Insert ] };
  key <DELE> { [ Delete ] };

  # -- ` 1234567890 -= <BSKP> --------------------------------------------------
  #
  # -- 49(`),10-22(1-0,-,=)

  # note that dead keys need to be configured in XCompose
  key <BKTK> { type= "FOUR_LEVEL"           , symbols[Group1]= [ grave     , asciitilde , dead_grave          , dead_tilde      ]};
  key <NUM1> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 1         , exclam,      exclamdown,           onesuperior     ]};
  key <NUM2> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 2         , at,          onehalf,              twosuperior     ]};
  key <NUM3> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 3         , numbersign,  sterling,             threesuperior   ]};
  key <NUM4> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 4         , dollar,      EuroSign,             dead_doubleacute]};
  key <NUM5> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 5         , percent,     currency,             dead_cedilla    ]};
  key <NUM6> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 6         , asciicircum, onequarter,           dead_circumflex ]};
  key <NUM7> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 7         , ampersand,   onethird,             dead_horn       ]};
  key <NUM8> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 8         , asterisk,    threequarters,        dead_ogonek     ]};
  key <NUM9> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 9         , parenleft,   leftsinglequotemark,  dead_breve      ]};
  key <NUM0> { type= "FOUR_LEVEL"           , symbols[Group1]= [ 0         , parenright,  rightsinglequotemark, dead_abovering  ]};
  key <APOS> { type= "FOUR_LEVEL"           , symbols[Group1]= [ minus     , underscore , yen                 , dead_belowdot   ]};
  key <RBRK> { type= "FOUR_LEVEL"           , symbols[Group1]= [ equal     , plus       , multiply            , division        ]};

  key <BKSP> { [ BackSpace, BackSpace ] };

  # -- <TAB> qwertuiop [] ------------------------------------------------------
  #
  # -- 23-35(TAB,q-l,[])

  key <TAB>  { [ Tab, ISO_Left_Tab ] };

  key <KP_X> {
    type= "FOUR_LEVEL_ALPHABETIC",
    symbols[Group1]= [ q           , Q         , adiaeresis     , Adiaeresis          ]
  };
  key <COMM> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ w           , W         , aring          , Aring               ]};
  key <KP_D> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ e           , E         , eacute         , Eacute              ]};
  key <KP_O> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ r           , R         , registered     , trademark           ]};
  key <KP_K> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ t           , T         ,  thorn         , THORN               ]};
  key <KP_T> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ y           , Y         , udiaeresis     , Udiaeresis          ]};
  key <KP_F> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ u           , U         , uacute         , Uacute              ]};
  key <KP_G> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ i           , I         , iacute         , Iacute              ]};
  key <KP_S> {
    type[1]= "FOUR_LEVEL_ALPHABETIC",
    symbols[1]= [ o           , O         , oacute         , Oacute              ],
    type[2]= "EIGHT_LEVEL_ALPHABETIC",
    # s, S, √ü, ¬ß, œÉ, Œ£, œÇ, êåΩ
    symbols[2] = [s,S,ssharp,section,Greek_sigma,Greek_SIGMA,Greek_finalsmallsigma,U1033D]
  };
  key <KP_R> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ p           , P         , odiaeresis     , Odiaeresis          ]};
  key <MNUS> { type= "FOUR_LEVEL"           , symbols[Group1]= [ bracketleft , braceleft , onefifth       , leftdoublequotemark ]};
  key <EQUL> { type= "FOUR_LEVEL"           , symbols[Group1]= [ bracketright, braceright, guillemotright , rightdoublequotemark]};

  # -- <CAPS> asdfghjkl;'# -----------------------------------------------------
  #
  # -- 66(CAPS),38-48(a-l,;,'),51(#),36(RTRN)


  key <CAPS> { type= "ONE_LEVEL", symbols[Group1]= [ Caps_Lock ], actions[Group1]= [ SetMods(modifiers=Control) ] };
#  key <CAPS> { [ Caps_Lock ] };

#  key <KP_A> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ a           , A         , aacute         , Aacute              ]};

  key <KP_A> { type= "EIGHT_LEVEL_ALPHABETIC", symbols[Group1]= [ a           , A         , aacute         , Aacute            , agrave, Agrave, aring, Aring  ]};
#  key.type="EIGHT_LEVEL_ALPHABETIC";
#  key <KP_A> { symbols[Group1]=[ a           , A         , aacute         , Aacute            , agrave, Agrave, aring, Aring  ]};


  key <SEMI> { type= "EIGHT_LEVEL_ALPHABETIC", symbols[Group1]= [ s           , S         , ssharp         , section             ]};
  key <KP_H> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ d           , D         ,    eth         , ETH                 ]};
  key <KP_Y> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ f           , F         , ediaeresis     , Ediaeresis          ]};
  key <KP_U> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ g           , G         , g              , G                   ]};
  key <KP_J> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ h           , H         , h              , H                   ]};
  key <KP_C> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ j           , J         , idiaeresis     , Idiaeresis          ]};
  key <KP_V> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ k           , K         , oe             , OE                  ]};
  key <KP_P> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ l           , L         , oslash         , Oslash              ]};

  key <KP_Z> { type= "FOUR_LEVEL"           , symbols[Group1]= [ semicolon   , colon     , paragraph      , degree              ]};

  # note that dead keys need to be configured in XCompose
  key <KP_Q> { type= "FOUR_LEVEL",            symbols[Group1]= [ apostrophe  , quotedbl  , dead_acute     , dead_diaeresis      ]};
#  key <HASH> { type= "FOUR_LEVEL"           , symbols[Group1]= [ numbersign  , asciitilde, dead_grave     , dead_breve          ]};

  key <RTRN> { [ Return ] };

  # -- <LFSH> \zxcvbnm,./ <RTSH> -----------------------------------------------
  #
  # -- 50(LSHFT),94(BCKSLSH),52-62(z-m,,./RSHFT)

  key <LFSH> { [ Shift_L ] };

#  key <BKSL> { type= "FOUR_LEVEL"           , symbols[Group1]= [ backslash   , bar       , backslash      , bar                 ]};
  key <HASH> { type= "FOUR_LEVEL"           , symbols[Group1]= [ backslash   , bar       , notsign      , bar                 ]};

  # note that dead keys need to be configured in XCompose
  key <SLSH> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ z           , Z         , ae             , AE                  ]};
  key <KP_B> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ x           , X         , periodcentered , dead_stroke         ]};
  key <KP_I> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ c           , C         , copyright      , cent                ]};
  key <PERD> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ v           , V         , v              , V                   ]};
  key <KP_N> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ b           , B         , b              , B                   ]};
  key <KP_L> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ n           , N         , ntilde         , Ntilde              ]};
  key <KP_M> { type= "FOUR_LEVEL_ALPHABETIC", symbols[Group1]= [ m           , M         , mu             , plusminus           ]};

  # note that dead keys need to be configured in XCompose
  key <KP_W> { type= "FOUR_LEVEL",            symbols[Group1]= [ comma       , less      , guillemotleft  , dead_caron          ]};
  key <KP_E> { type= "FOUR_LEVEL",            symbols[Group1]= [ period      , greater   , guillemotright , dead_abovedot       ]};
  key <LBRK> { type= "FOUR_LEVEL",            symbols[Group1]= [ slash       , question  , questiondown   , dead_hook           ]};

  key <RTSH> { [ Shift_R ] };

  # -- <CTL> <FN> <SPR> <ALT> <SPACEBAR> <ALTGR> <CTL> (FNGR) ------------------
  #
  # -- 37(LCTL),151(FN),133(SUPER),64(ALT),65(SPACE),108(ALTGR),105(RCTL),112(PGUP),111(UP),117(PGDN),113(LEFT),116(DOWN),114(RGHT)

  key <LCTL> { [ Control_L     ] };
  # <FUNCTION>
  key <LWIN> { [ Super_L       ] };
  key <LALT> { [ Alt_L, Meta_L ] };
  key <SPCE> { [ space         ] };
  key <RALT> { [ Hyper_R ] };
  key <RCTL> { [ Control_R     ] };

  # <PGUP> <UP> <PGDN> <LEFT> <DOWN> <RGHT> ----------------

  key <PGUP> { [ Prior ] };
  key  <UP>  { [ Up    ] };
  key <PGDN> { [ Next  ] };
  key <LEFT> { [ Left  ] };
  key <DOWN> { [ Down  ] };
  key <RGHT> { [ Right ] };

  # ----------------------------------------------------------------------------


    key <SCLK> {         [     Scroll_Lock ] };


    key <PRSC> {
        type= "ONE_LEVEL",
symbols[Group1]=[ISO_Next_Group]
    };
    key <BKSL> {
        type= "TWO_LEVEL",
        symbols[Group1]= [ Multi_key, Hyper_L ]
    };
    key <MUTE> {         [   XF86AudioMute ] };
    key <VOL-> {         [ XF86AudioLowerVolume ] };
    key <VOL+> {         [ XF86AudioRaiseVolume ] };
    key <PAUS> {
        type= "PC_CONTROL_LEVEL2",
        symbols[Group1]= [           Pause,           Break ]
    };
    key <I151> {         [      XF86WakeUp ] };
    key <SNIP> {         [     XF86Launch2 ] };
    key <STAR> {         [   XF86Favorites ] };
    key <MCMT> {         [ XF86AudioMicMute ] };
    key <FRSH> {         [     XF86Launch3 ] };
    key <BRT-> {         [ XF86MonBrightnessDown ] };
    key <BRT+> {         [ XF86MonBrightnessUp ] };
    key <DISP> {         [     XF86Display ] };

    modifier_map Control { <LCTL> };
    modifier_map Control { <RCTL> };
    modifier_map Control { <CAPS> };

    modifier_map Shift { <LFSH> };
    modifier_map Shift { <RTSH> };

    modifier_map Mod1 { <LALT> };
#    modifier_map Mod1 { <ALT> };
#    modifier_map Mod1 { <META> };

#    modifier_map Mod2 { <NMLK> };

#    modifier_map Mod3 { <LVL5> };

    modifier_map Mod4 { <LWIN> };
#    modifier_map Mod4 { <RWIN> };
#    modifier_map Mod4 { <SUPR> };
#    modifier_map Mod4 { <HYPR> };

    modifier_map Mod5 { <RALT> };
};

};

# Local Variables:
# fill-column: 132
# End:
